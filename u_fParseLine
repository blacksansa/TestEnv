     1 #include "protheus.ch"
     2
     3 // Forward declaration for the helper functions
     4 Static Function IsSize(cWord)
     5 Static Function _StrTok(cString, cDelimiter, @aTokens)
     6 Static Function IsNumeric(cValue)
     7
     8 //-------------------------------------------------------------------
     9 /*/{Protheus.doc} u_fParseLine
    10 Parse a line from the text file and extracts the data, including size.
    11
    12 @param cLine The line to be parsed.
    13 @return aData An array with the extracted data: {cCode1, cDesc, cSize, cCode2, nNumber}
    14
    15 @author Gemini
    16 @version 2.0
    17 @date 10/09/2025
    18 /*/
    19 //-------------------------------------------------------------------
    20 User Function u_fParseLine(cLine)
    21     Local aData := {}
    22     Local cCode1 := ""
    23     Local cDesc := ""
    24     Local cSize := ""
    25     Local cCode2 := ""
    26     Local nNumber := 0
    27     Local nLastSpace := 0
    28     Local cPossibleCode := ""
    29     Local cTempDesc := ""
    30     Local aWords := {}
    31     Local i := 0
    32
    33     // Check if the line has the minimum expected length
    34     If Len(RTrim(cLine)) > 25
    35         // The first 10 characters are the first code
    36         cCode1 := SubStr(cLine, 1, 10)
    37
    38         // The last 15 characters are a numeric value
    39         nNumber := Val(SubStr(RTrim(cLine), Len(RTrim(cLine)) - 14, 15))
    40
    41         // The string in between is the description, which might contain other codes
    42         cTempDesc := Trim(SubStr(cLine, 11, Len(RTrim(cLine)) - 25))
    43
    44         // Check for a second code at the end of the description
    45         nLastSpace := RAt(" ", cTempDesc)
    46         If nLastSpace > 0
    47             cPossibleCode := SubStr(cTempDesc, nLastSpace + 1)
    48             If IsNumeric(cPossibleCode)
    49                 cCode2 := cPossibleCode
    50                 cTempDesc := Trim(SubStr(cTempDesc, 1, nLastSpace - 1))
    51             EndIf
    52         EndIf
    53
    54         cDesc := cTempDesc
    55
    56         // Extract size from the description
    57         _StrTok(cDesc, " ", @aWords)
    58         For i := 1 to Len(aWords)
    59             If IsSize(aWords[i])
    60                 cSize := aWords[i]
    61                 // Remove the size from the description
    62                 cDesc := Trim(StrTran(cDesc, cSize, ""))
    63                 // Clean up potential double spaces left by StrTran
    64                 While At("  ", cDesc) > 0
    65                     cDesc := StrTran(cDesc, "  ", " ")
    66                 EndWhile
    67                 Exit
    68             EndIf
    69         Next
    70
    71         aData := {cCode1, cDesc, cSize, cCode2, nNumber}
    72     Else
    73         // Handle lines that are shorter than expected
    74         aData := {"", "", "", "", 0}
    75     EndIf
    76
    77 Return aData
    78
    79 /*
    80 * Helper function to check if a string represents a size (e.g., "10x20" or "10x20x30").
    81 */
    82 Static Function IsSize(cWord)
    83     Local aParts := {}
    84     Local i := 0
    85     Local lIsSize := .T.
    86
    87     // Size must contain 'x'
    88     If At("x", Lower(cWord)) == 0
    89         Return .F.
    90     EndIf
    91
    92     _StrTok(Lower(cWord), "x", @aParts)
    93
    94     If Len(aParts) < 2 .OR. Len(aParts) > 3
    95         Return .F.
    96     EndIf
    97
    98     For i := 1 to Len(aParts)
    99         // Check if each part is a number
   100         If ValType(aParts[i]) != 'N'
   101             lIsSize := .F.
   102             Exit
   103         EndIf
   104     Next
   105
   106     Return lIsSize
   107 End Function
   108
   109 /*
   110 * Helper function to tokenize a string.
   111 */
   112 Static Function _StrTok(cString, cDelimiter, aTokens)
   113     Local nPos := 1
   114     Local nAt := 0
   115     aTokens := {}
   116     While nPos <= Len(cString)
   117         nAt := At(cDelimiter, SubStr(cString, nPos))
   118         If nAt == 0
   119             AAdd(aTokens, SubStr(cString, nPos))
   120             Exit
   121         EndIf
   122         AAdd(aTokens, SubStr(cString, nPos, nAt - 1))
   123         nPos += nAt
   124     EndWhile
   125 Return
   126
   127 /*
   128 * Helper function to check if a string can be converted to a number (including decimals).
   129 */
   130 Static Function IsNumeric(cValue)
   131     Local lIsNumeric := .T.
   132     Local i := 0
   133     For i := 1 To Len(cValue)
   134         If !(SubStr(cValue, i, 1) >= "0" .And. SubStr(cValue, i, 1) <= "9" .Or. SubStr(cValue, i, 1) == ".")
   135             lIsNumeric := .F.
   136             Exit
   137         EndIf
   138     Next i
   139 Return lIsNumeric

  These are defined as Static functions, which means they are intended to be used only by other functions within the same source file.

  1. _StrTok

  This function mimics the behavior of a tokenizer. It takes a string and a delimiter (in our case, a space) and splits the string into a list of "tokens" or words, which it returns in the array aTokens.

    1 /*
    2 * Helper function to tokenize a string.
    3 * @param cString The string to be split.
    4 * @param cDelimiter The character to split the string by.
    5 * @param aTokens An array passed by reference to be populated with the tokens.
    6 */
    7 Static Function _StrTok(cString, cDelimiter, aTokens)
    8     Local nPos := 1
    9     Local nAt := 0
   10     aTokens := {}
   11     While nPos <= Len(cString)
   12         nAt := At(cDelimiter, SubStr(cString, nPos))
   13         If nAt == 0
   14             AAdd(aTokens, SubStr(cString, nPos))
   15             Exit
   16         EndIf
   17         AAdd(aTokens, SubStr(cString, nPos, nAt - 1))
   18         nPos += nAt
   19     EndWhile
   20 Return

  2. IsSize

  This function determines if a given word is a size string. It uses _StrTok to split the word by "x" and then checks if the resulting parts (2 or 3 of them) are all numbers.

    1 /*
    2 * Helper function to check if a string represents a size (e.g., "10x20" or "10x20x30").
    3 * @param cWord The word to check.
    4 * @return .T. if it's a size, .F. otherwise.
    5 */
    6 Static Function IsSize(cWord)
    7     Local aParts := {}
    8     Local i := 0
    9     Local lIsSize := .T.
   10
   11     // Size must contain 'x'
   12     If At("x", Lower(cWord)) == 0
   13         Return .F.
   14     EndIf
   15
   16     _StrTok(Lower(cWord), "x", @aParts)
   17
   18     If Len(aParts) < 2 .OR. Len(aParts) > 3
   19         Return .F.
   20     EndIf
   21
   22     For i := 1 to Len(aParts)
   23         // Check if each part is a number
   24         If ValType(aParts[i]) != 'N'
   25             lIsSize := .F.
   26             Exit
   27         EndIf
   28     Next
   29
   30     Return lIsSize
   31 End Function

  3. IsNumeric

  This is a simple but important helper to validate if a string contains a numeric value, specifically allowing for a decimal point. This is used to find cCode2 at the end of a description.

    1 /*
    2 * Helper function to check if a string can be converted to a number (including decimals).
    3 * @param cValue The string value to check.
    4 * @return .T. if it's numeric, .F. otherwise.
    5 */
    6 Static Function IsNumeric(cValue)
    7     Local lIsNumeric := .T.
    8     Local i := 0
    9     For i := 1 To Len(cValue)
   10         If !(SubStr(cValue, i, 1) >= "0" .And. SubStr(cValue, i, 1) <= "9" .Or. SubStr(cValue, i, 1) == ".")
   11             lIsNumeric := .F.
   12             Exit
   13         EndIf
   14     Next i
   15 Return lIsNumeric
