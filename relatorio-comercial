#include "protheus.ch"
#include "file.ch"

/*-----------------------------------------------------------
  Function: IMP_ATU_COND()
  Description: Importa CSV, confere registros e atualiza se todos existirem
  Author: [Seu nome]
  Date: [Data]
  Param: N/A
  Return: N/A
-----------------------------------------------------------*/
User Function IMP_ATU_COND()
    Local cArqPath   
    Local nHandle    
    Local cLinha     
    Local aCampos    
    
    Local lTodosEncontrados := .T. 
    Local cLogFile          := "Importacao_Log_" + DToS(Date()) + Time() + ".log" 
    Local nLogHandle        := -1 
    
    Local aEstrutura := { {"ID_DADOS", "C", 20, 0}, {"DESCRICAO", "C", 50, 0} }

    // 1. Tenta criar a tabela temporária e verifica se a operação foi bem-sucedida.
    If !DBCreate("TMP_DADOS", aEstrutura)
        MsgStop("Falha ao criar a tabela temporária 'TMP_DADOS'. Processo cancelado.", "Erro")
        Return .F.
    EndIf
    
    DbSelectArea("TMP_DADOS")
    
    // 2. Permite que o usuário selecione o arquivo CSV.
    cArqPath := cGetFile("*.csv", "Selecione o arquivo CSV", "C:\")
    
    If Empty(cArqPath)
        MsgInfo("Importação cancelada pelo usuário.", "Aviso")
        Return .F.
    EndIf
    
    nHandle := FOpen(cArqPath)
    If nHandle < 0
        MsgStop("Erro ao abrir o arquivo. Processo cancelado.", "Erro")
        Return .F.
    EndIf
    
    MsgInfo("Iniciando a leitura do arquivo e inserção na tabela temporária...", "Aguarde")
    
    // 3. Lê o CSV e insere os dados na tabela temporária.
    While !FEof(nHandle)
        cLinha := FGetC(nHandle)
        If Empty(cLinha)
            Loop
        EndIf

        aCampos := FWcToA(cLinha, ",")
        If Len(aCampos) <> 2 
            Loop
        EndIf

        MsNew("TMP_DADOS")
        TMP_DADOS->ID_DADOS  := AllTrim(aCampos[1])
        TMP_DADOS->DESCRICAO := AllTrim(aCampos[2])
        MsCommit()
    EndDo
    FClose(nHandle)
    
    // 4. Inicia a conferência dos registros e a geração do log.
    nLogHandle := FOpen(cLogFile, FW_CREATE)
    If nLogHandle < 0
        MsgStop("Não foi possível criar o arquivo de log.", "Erro")
        lTodosEncontrados := .F. 
    Else
        FWrite(nLogHandle, "Registros Nao Encontrados" + CRLF)
        FWrite(nLogHandle, "-----------------------------------" + CRLF)
        
        DbSelectArea("TMP_DADOS")
        DbGoTop()
        
        While !Eof()
            DbSelectArea("SA1")
            DbSetOrder(1) 
            If !DbSeek(TMP_DADOS->ID_DADOS) 
                lTodosEncontrados := .F.
                FWrite(nLogHandle, "CAM1: " + AllTrim(TMP_DADOS->ID_DADOS) + ", CAM2: " + AllTrim(TMP_DADOS->DESCRICAO) + CRLF)
            EndIf
            
            DbSelectArea("TMP_DADOS")
            DbSkip()
        EndDo
    EndIf
    
    FClose(nLogHandle)

    // 5. Bloco de decisão: Cancelar ou Atualizar.
    If !lTodosEncontrados
        MsgStop("Processo de importação cancelado." + CRLF + "Verifique o log em: " + cLogFile, "Importação Cancelada")
    Else
        MsgInfo("Todos os " + cValToChar(RecCount("TMP_DADOS")) + " registros foram encontrados!" + CRLF + "Iniciando a atualização da tabela SA1...", "Aguarde")
        
        DbSelectArea("TMP_DADOS")
        DbGoTop()
        
        While !Eof()
            DbSelectArea("SA1")
            DbSetOrder(1)
            If DbSeek(TMP_DADOS->ID_DADOS)
                MSLock()
                SA1->A1_NOME := TMP_DADOS->DESCRICAO 
                MsUnLock()
                DbCommit()
            EndIf
            
            DbSelectArea("TMP_DADOS")
            DbSkip()
        EndDo
        
        MsgInfo("Atualização de todos os registros concluída com sucesso!", "Sucesso")
        FErase(cLogFile)
    EndIf
    
    // 6. Limpeza: fecha a área de trabalho da tabela temporária.
    DbCloseArea("TMP_DADOS")

Return .T.
